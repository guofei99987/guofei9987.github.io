---
layout: post
title: 【算法理论3】Tree
categories:
tags: 8_数据结构与算法
keywords:
description:
order: 503
---





## Tree的相关定义
**根节点**：没有父节点的点  
**节点的度**：某个节点拥有子节点的个数  
**叶节点**：度为0的节点  
**分支节点**：度不为0的节点  
**子节点**  
**父节点**  
**兄弟节点**：共享同一个`父节点`的节点  
**树的度**：所有节点的度的最大值  
**节点的层次**：从根节点到某节点路径上的分支数，根节点的层次是0， 任意节点的层次=父节点的层次+1  
**树的深度**：所有节点的层次的最大值。空树的深度是-1，只有一个根节点的树的深度是0  
**无序树**：兄弟节点是无序的  
**有序树**：兄弟节点是有序的。`二叉树`是一种有序树。  
**森林**：m($m\geq 0$)颗树的集合叫做森林。一棵树的根节点有m颗子树，那么删掉根节点后，就变成包含m颗树的森林


对树进行删除、插入、搜索操作，最坏情况下复杂度为$\Theta(\lg n)$

## Tree的代码表示

### 父节点表示法

|点|父节点|
|--|--|
|0|-1|
|1|0|
|2|0|
|3|1|
|...|...|

优点：寻找父节点方便  
缺点：寻找子节点不方便  

### 子节点表示法

实现难点在于子节点的个数未知

|点|子节点|
|--|--|
|||
|||


对于二叉树：

|点|左子节点|右子节点|
|--|--|--|
||||
|||


### 父子节点表示法

既有父节点，又有子节点

### 子兄弟表示法
既有子节点，也有兄弟节点

## 二叉树

二叉树是一种`有序树`，由一个根节点和两个互不相交的子二叉树构成，两个自子二叉树分别叫做`左子树`和`右子树`  

**满二叉树** ：一颗二叉树上，所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层。  

**完全二叉树**：一个有n个节点的二叉树与某个满二叉树的前n个节点结构完全相同，这样的二叉树叫做完全二叉树。*（可以理解为满二叉树去掉后面某些节点）*  

### 二叉树的性质


- 第i层上最多有$2^i$个节点  
- 深度为k的二叉树，最多有$2^{k+1}-1$个节点  
- 一个完全二叉树有n个节点，那么深度$k=\log_2(n+1)-1$  
- 一个二叉树，度为0,1,2的节点数为$n_0,n_1,n_2$, 那么， $n_0=n_2+1$
- 一个具有n个节点的完全二叉树，如果从上至下和从左至右从0开始编号那么，对于序号为i个节点，有：
    1. 如果i>0,双亲节点序号是 (i-1)//2; 如果i=0，那么i是根节点，无双亲节点
    2. 如果2i+1<n,那么左子节点序号为2i+1; 如果2i+1>=n, 那么无左子节点
    3. 如果2i+2<n,那么右子节点序号是2i+2; 如果2i+2>=n, 那么无右子节点


### 二叉树的存储

#### 顺序存储结构
可以简单理解为用一个 list 存放二叉树的每一个结点  


[heapq](http://www.guofei.site/2017/09/11/heapq.html)就是以这种方式存储二叉树的  
我写了一个Python实现，见于[这里](/2018/07/04/pythona_tree.html#title1)  
对于完全二叉树，节省存储空间，实现简单。如果空节点太多，就不适合了。  

#### 链式存储

每个节点如下：  

|leftChild|data|rightChild|
|--|--|--|
||||

左和右都是指针，指向下一个节点  

#### 仿真指针

就是上文中的子节点表示法  

存储下面的这个表：  

|data|leftChild|rightChild|
|--|--|--|
|0|1|2|
|1|3|-1|
|...|...|...|

(-1表示空指针)  
### 二叉树遍历
规定 D,L,R 分别代表“访问根节点”，“访问根节点的左子树”,“访问根节点的右子树”，这样便有6中遍历方式：  
LDR,DLR,LRD,RDL,DRL,RLD  
因为先遍历左子树和先遍历右子树的算法很相似，所以研究这几种遍历方式：  
前序遍历(DLR)，中序遍历(LDR)，后序遍历(LRD)  


给定一个遍历序列并不能唯一决定一个二叉树，但给定一个二叉树序列的前序遍历序列和一个中序遍历序列，可以唯一确定一个二叉树。  
